<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨å¿ã³ãƒ€ãƒ¼ãƒ“ãƒ¼</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* CSSã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #e3f2fd, #e8f5e8); min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .title { font-size: 2.5rem; font-weight: bold; color: #6a1b9a; margin-bottom: 10px; }
        .stats { display: flex; justify-content: center; gap: 30px; margin-bottom: 20px; }
        .stat-item { background: white; padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .score { color: #2e7d32; font-weight: bold; }
        .race-count { color: #1565c0; font-weight: bold; }
        .viewport { background: white; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; overflow: hidden; position: relative; }
        #gameCanvas { width: 100%; height: 400px; display: block; }
        .control-panel { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .phase-title { text-align: center; font-size: 1.8rem; color: #333; margin-bottom: 30px; }
        .horse-selection { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .horse-card { padding: 20px; border: 3px solid #e0e0e0; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-align: center; background: #f5f5f5; }
        .horse-card:hover { border-color: #9c27b0; }
        .horse-card.selected { border-color: #6a1b9a; transform: scale(1.05); background: #f3e5f5; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .horse-emoji { font-size: 2rem; margin-bottom: 10px; }
        .horse-name { font-size: 1.2rem; font-weight: bold; color: #333; margin-bottom: 5px; }
        .horse-lane { font-size: 0.9rem; color: #666; }
        .player-count-selection { display: flex; justify-content: center; gap: 15px; margin-bottom: 30px; }
        .count-button { background: #f0f0f0; border: 2px solid #ccc; padding: 12px 25px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .count-button:hover { background: #e0e0e0; border-color: #aaa; }
        .start-button { display: block; margin: 0 auto; background: #6a1b9a; color: white; border: none; padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .start-button:hover { background: #4a148c; }
        .racing-phase, .result-phase { text-align: center; }
        .racing-phase h2 { font-size: 1.8rem; color: #333; margin-bottom: 15px; }
        .prediction { font-size: 1.1rem; color: #666; }
        .result-phase h2 { font-size: 2.2rem; color: #6a1b9a; margin-bottom: 20px; }
        .winner-announcement { font-size: 1.5rem; color: #6a1b9a; margin-bottom: 10px; }
        .celebration { font-size: 3rem; margin-bottom: 20px; }
        .result-message { padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .success { background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32; }
        .failure { background: #ffebee; border: 2px solid #f44336; color: #c62828; }
        .result-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 10px; }
        .points { font-size: 1.1rem; }
        .reset-button { background: #1565c0; color: white; border: none; padding: 12px 30px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(21, 101, 192, 0.3); }
        .reset-button:hover { background: #0d47a1; }
        #loadingOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; font-size: 2rem; color: #333; z-index: 100; }
        @media (max-width: 768px) {
            .title { font-size: 2rem; }
            .stats { flex-direction: column; gap: 15px; }
            .horse-selection { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">Now Loading...</div>
    
    <div class="container"></div>

    <audio id="raceBgm" src="race_bgm.mp3" loop></audio>

    <script>
        // å¤‰æ•°ãƒ»å®šæ•°ã¯å¤‰æ›´ãªã—
        let obstacles = [], obstacleMeshes = [], stumbleTimers = [];
        let gameState = 'setup', selectedHorse = null, winner = null, score = 0, raceCount = 0;
        let numHorses = 0, raceProgress = [], speeds = [];
        let scene, camera, renderer, characters = [], animationId;
        const allHorses = [
            { id: 0, name: 'ã‚·ãƒ£ã‚ªãƒ©ãƒ³' }, { id: 1, name: 'ã‚µã‚¯ãƒ¤' },
            { id: 2, name: 'ãƒãƒ ' }, { id: 3, name: 'ãƒ’ãƒŠãƒã‚¸ãƒ§ã‚¦' }
        ];
        let currentHorses = [];
        const TRACK_LENGTH = 20, FINISH_LINE = 18, MAX_HORSES = 4;

        // inité–¢æ•°ã¯å¤‰æ›´ãªã—
        function init() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 12); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-5, 10, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const trackWidth = MAX_HORSES * 2;
            const trackGeometry = new THREE.PlaneGeometry(trackWidth, TRACK_LENGTH);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2; track.receiveShadow = true; scene.add(track);
            const startLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const startLineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const startLine = new THREE.Mesh(startLineGeometry, startLineMaterial);
            startLine.position.set(0, 0.01, -TRACK_LENGTH/2 + 1); scene.add(startLine);
            const finishLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const finishLineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const finishLine = new THREE.Mesh(finishLineGeometry, finishLineMaterial);
            finishLine.position.set(0, 0.01, TRACK_LENGTH/2 - 1); scene.add(finishLine);

            const loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => {
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('setupPhase').style.display = 'block';
            };
            const textureLoader = new THREE.TextureLoader(loadingManager);
            const characterImageFiles = ['syaoran1.webp', 'sakuya1.webp', 'remu1.webp', 'hinanojyou1.webp'];
            for (let i = 0; i < MAX_HORSES; i++) {
                const texture = textureLoader.load(characterImageFiles[i]);
                const planeGeometry = new THREE.PlaneGeometry(1.2, 1.8);
                const planeMaterial = new THREE.MeshLambertMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const characterPlane = new THREE.Mesh(planeGeometry, planeMaterial);
                characterPlane.castShadow = true; characterPlane.visible = false;
                characters.push(characterPlane); scene.add(characterPlane);
            }
        }
        
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šéšœå®³ç‰©ã‚’ã€Œï¼‘ã¤ã ã‘ã€ç”Ÿæˆã™ã‚‹é–¢æ•°ã«å¤‰æ›´ â˜…â˜…â˜…
        function createSingleObstacle(lane, positionZ) {
            const lanePositionX = (lane - (numHorses - 1) / 2) * 2;
            
            // ä»–ã®éšœå®³ç‰©ã¨ä½ç½®ãŒè¿‘ã™ãã‚‹å ´åˆã¯ç”Ÿæˆã—ãªã„
            for(const obs of obstacles) {
                if (Math.abs(obs.z - positionZ) < 2.0) {
                    return; // ä½ç½®ãŒè¿‘ã™ãã‚‹ã®ã§ä¸­æ­¢
                }
            }

            const isRock = Math.random() > 0.5;
            const obstacleData = { lane, z: positionZ };
            obstacles.push(obstacleData);

            let obstacleMesh;
            if(isRock) { // å²©
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.25, positionZ);
            } else { // ã‚‚ãã‚‰ã®ç©´
                const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const material = new THREE.MeshStandardMaterial({ color: 0x4e342e });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.05, positionZ);
            }
            obstacleMesh.castShadow = true;
            scene.add(obstacleMesh);
            obstacleMeshes.push(obstacleMesh);
        }
        
        // jumpCharacteré–¢æ•°ã¯å¤‰æ›´ãªã—
        function jumpCharacter(index) { const character = characters[index]; if (character.isJumping) return; character.isJumping = true; const originalY = character.position.y; const jumpHeight = 1.0; let jumpProgress = 0; const jumpInterval = setInterval(() => { jumpProgress += 0.1; character.position.y = originalY + Math.sin(jumpProgress * Math.PI) * jumpHeight; if (jumpProgress >= 1) { character.position.y = originalY; character.isJumping = false; clearInterval(jumpInterval); } }, 30); }

        // â˜…â˜…â˜… ãƒ¬ãƒ¼ã‚¹é–‹å§‹å‡¦ç†ã‚’å¤§å¹…ã«å¤‰æ›´ â˜…â˜…â˜…
        function startRace() {
            if (selectedHorse === null) { alert('äºˆæƒ³ã™ã‚‹å¿ã³ã‚’é¸ã‚“ã§ãã ã•ã„ï¼'); return; }

            // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šãƒ¬ãƒ¼ã‚¹é–‹å§‹æ™‚ã®éšœå®³ç‰©ç”Ÿæˆã‚’å‰Šé™¤ â˜…â˜…â˜…
            // generateObstacles(); // ã“ã®è¡Œã‚’å‰Šé™¤

            stumbleTimers = new Array(numHorses).fill(0);
            let spawnedObstacleCount = 0; // ã“ã®ãƒ¬ãƒ¼ã‚¹ã§ç”Ÿæˆã—ãŸéšœå®³ç‰©ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            const MAX_OBSTACLES_PER_RACE = 2; // ãƒ¬ãƒ¼ã‚¹ä¸­ã«ç”Ÿæˆã™ã‚‹éšœå®³ç‰©ã®æœ€å¤§æ•°

            const raceBgm = document.getElementById('raceBgm');
            raceBgm.play().catch(e => console.error("BGMã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", e));

            gameState = 'racing';
            raceProgress = new Array(numHorses).fill(0);
            speeds = new Array(numHorses).fill(0);
            winner = null;

            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'block';
            document.getElementById('selectedHorseName').textContent = currentHorses[selectedHorse].name;

            const raceInterval = setInterval(() => {
                
                // â˜…â˜…â˜… è¿½åŠ ç‚¹ï¼šãƒ¬ãƒ¼ã‚¹ä¸­ã«éšœå®³ç‰©ã‚’å‹•çš„ã«ç”Ÿæˆã™ã‚‹å‡¦ç† â˜…â˜…â˜…
                if (spawnedObstacleCount < MAX_OBSTACLES_PER_RACE && Math.random() < 0.015) {
                    // 1.5%ã®ç¢ºç‡ã§éšœå®³ç‰©ã‚’ç”Ÿæˆ
                    let leaderIndex = 0;
                    let maxProgress = 0;
                    // ç¾åœ¨ã®ãƒˆãƒƒãƒ—èµ°è€…ã‚’èª¿ã¹ã‚‹
                    raceProgress.forEach((prog, index) => {
                        if (prog > maxProgress) {
                            maxProgress = prog;
                            leaderIndex = index;
                        }
                    });

                    // ãƒˆãƒƒãƒ—èµ°è€…ã®å°‘ã—å‰ã«éšœå®³ç‰©ã‚’ç½®ã
                    const spawnZ = -TRACK_LENGTH / 2 + 1 + maxProgress + 3.0; // 3ãƒ¦ãƒ‹ãƒƒãƒˆå‰
                    if (spawnZ < FINISH_LINE - 2) { // ã‚´ãƒ¼ãƒ«ç›´å‰ã«ã¯ç½®ã‹ãªã„
                        createSingleObstacle(leaderIndex, spawnZ);
                        spawnedObstacleCount++;
                    }
                }

                // å„ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®å‡¦ç†ï¼ˆã“ã“ã¯å¤‰æ›´ãªã—ï¼‰
                for (let i = 0; i < numHorses; i++) {
                    const character = characters[i];
                    if (stumbleTimers[i] > 0) {
                        stumbleTimers[i]--;
                        speeds[i] = 0;
                        if (stumbleTimers[i] === 0) character.rotation.x = 0;
                        continue;
                    }

                    let obstacleAhead = false;
                    const characterZ = -TRACK_LENGTH / 2 + 1 + raceProgress[i];
                    for (const obs of obstacles) {
                        if (obs.lane === i && obs.z > characterZ && obs.z - characterZ < 1.5) {
                            obstacleAhead = true;
                            break;
                        }
                    }

                    if (obstacleAhead && !character.isJumping) {
// ã‚¸ãƒ£ãƒ³ãƒ—ã‚’è©¦ã¿ã‚‹ç¢ºç‡ (èª¿æ•´å¯èƒ½)
if (Math.random() < 0.6) {
jumpCharacter(i);
} else {
// ã‚¸ãƒ£ãƒ³ãƒ—ã«å¤±æ•—ã—ãŸå ´åˆï¼ˆã¾ãŸã¯ã‚¸ãƒ£ãƒ³ãƒ—ã‚’è©¦ã¿ãªã‹ã£ãŸå ´åˆï¼‰ã€ã¤ã¾ãšãç¢ºç‡
if (Math.random() < 0.7) {
stumbleTimers[i] = 20;
character.rotation.x = 0.5;
}
// ã¤ã¾ãšãã‚‚å›é¿ã™ã‚‹å¯èƒ½æ€§ (ä½ç¢ºç‡)
}
}

                    speeds[i] = Math.random() * 0.18 + 0.04;
                    raceProgress[i] = Math.min(FINISH_LINE, raceProgress[i] + speeds[i]);
                }

                // ã‚´ãƒ¼ãƒ«åˆ¤å®šï¼ˆã“ã“ã¯å¤‰æ›´ãªã—ï¼‰
                const finished = raceProgress.findIndex(progress => progress >= FINISH_LINE);
                if (finished !== -1) {
                    clearInterval(raceInterval);
                    winner = finished;
                    gameState = 'finished';
                    if (finished === selectedHorse) score += 10;
                    raceCount++;
                    updateUI();
                    showResult();
                }
            }, 100);
        }
        
        // ã“ã‚Œä»¥é™ã®é–¢æ•°ã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“
        function resetGame() { const raceBgm = document.getElementById('raceBgm'); raceBgm.pause(); raceBgm.currentTime = 0; obstacleMeshes.forEach(mesh => scene.remove(mesh)); obstacles = []; obstacleMeshes = []; gameState = 'setup'; selectedHorse = null; winner = null; numHorses = 0; currentHorses = []; characters.forEach(c => { c.visible = false; c.rotation.set(0,0,0); c.isJumping = false; }); document.getElementById('resultPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'none'; document.getElementById('racingPhase').style.display = 'none'; document.getElementById('setupPhase').style.display = 'block'; }
        function setupRace(count) { numHorses = count; currentHorses = allHorses.slice(0, numHorses); gameState = 'betting'; document.getElementById('setupPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'block'; generateHorseSelection(); resetCharacters(); }
        function generateHorseSelection() { const selectionDiv = document.getElementById('horseSelection'); selectionDiv.innerHTML = ''; currentHorses.forEach((horse, index) => { const card = document.createElement('div'); card.className = 'horse-card'; card.dataset.horse = index; card.innerHTML = ` <div class="horse-emoji">ğŸƒâ€â™€ï¸</div> <div class="horse-name">${horse.name}</div> <div class="horse-lane">ãƒ¬ãƒ¼ãƒ³ ${index + 1}</div> `; card.addEventListener('click', () => { document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedHorse = index; }); selectionDiv.appendChild(card); }); }
        function resetCharacters() { characters.forEach((character, index) => { if (index < numHorses) { character.visible = true; const lanePositionX = (index - (numHorses - 1) / 2) * 2; character.position.set(lanePositionX, 0.9, -TRACK_LENGTH / 2 + 1); } else { character.visible = false; } }); }
        function animate() { animationId = requestAnimationFrame(animate); if (gameState === 'racing') { characters.forEach((character, index) => { if (index < numHorses && !character.isJumping) { const time = Date.now() * 0.01; character.rotation.y = Math.sin(time + index * 2) * 0.1; } }); } characters.forEach((character, index) => { if (index < numHorses) { const startZ = -TRACK_LENGTH/2 + 1; const targetZ = startZ + raceProgress[index]; character.position.z = THREE.MathUtils.lerp(character.position.z, targetZ, 0.1); } }); renderer.render(scene, camera); }
        function onWindowResize() { const canvas = document.getElementById('gameCanvas'); if (canvas) { camera.aspect = canvas.clientWidth / canvas.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvas.clientWidth, canvas.clientHeight); } }
        function showResult() { document.getElementById('racingPhase').style.display = 'none'; document.getElementById('resultPhase').style.display = 'block'; document.getElementById('winnerName').textContent = currentHorses[winner].name; const resultMessage = document.getElementById('resultMessage'); const resultTitle = resultMessage.querySelector('.result-title'); const points = resultMessage.querySelector('.points'); if (selectedHorse === winner) { resultMessage.className = 'result-message success'; resultTitle.textContent = 'ğŸ‰ äºˆæƒ³çš„ä¸­ï¼ ğŸ‰'; points.textContent = '+10ãƒã‚¤ãƒ³ãƒˆç²å¾—ï¼'; } else { resultMessage.className = 'result-message failure'; resultTitle.textContent = 'ğŸ˜… äºˆæƒ³å¤–ã‚Œ...'; points.textContent = `ã‚ãªãŸã®äºˆæƒ³: ${currentHorses[selectedHorse].name}`; } }
        function updateUI() { document.getElementById('score').textContent = score; document.getElementById('raceCount').textContent = raceCount; }
        window.addEventListener('load', () => { init(); animate(); window.addEventListener('resize', onWindowResize); });
    </script>
</body>
</html>
