<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨å¿ã³ãƒ€ãƒ¼ãƒ“ãƒ¼</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* CSSã®å¤‰æ›´ã¯å°‘ãªã„ã§ã™ãŒã€å…¨ä½“ã‚’è²¼ã‚Šæ›¿ãˆã¦ãã ã•ã„ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #e3f2fd, #e8f5e8); min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .title { font-size: 2.5rem; font-weight: bold; color: #6a1b9a; margin-bottom: 10px; }
        .stats { display: flex; justify-content: center; gap: 30px; margin-bottom: 20px; }
        .stat-item { background: white; padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .score { color: #2e7d32; font-weight: bold; }
        .race-count { color: #1565c0; font-weight: bold; }
        .viewport { background: white; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; overflow: hidden; position: relative; }
        #gameCanvas { width: 100%; height: 400px; display: block; }
        .control-panel { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .phase-title { text-align: center; font-size: 1.8rem; color: #333; margin-bottom: 30px; }
        .horse-selection { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        
        /* â˜…â˜…â˜… CSSå¤‰æ›´ç‚¹ï¼šã‚«ãƒ¼ãƒ‰ã®ãƒ‡ã‚¶ã‚¤ãƒ³æ”¹å–„ â˜…â˜…â˜… */
        .horse-card {
            padding: 20px;
            border: 3px solid #e0e0e0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            background: #f5f5f5;
            position: relative; /* èƒŒæ™¯ç”»åƒã®ãŸã‚ã«å¿…è¦ */
            overflow: hidden;   /* èƒŒæ™¯ç”»åƒãŒã¯ã¿å‡ºãªã„ã‚ˆã†ã« */
            z-index: 1;
        }
        .horse-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image: var(--char-bg); /* JSã‹ã‚‰ç”»åƒã‚’æŒ‡å®š */
            background-size: cover;
            background-position: center;
            opacity: 0.15; /* ç”»åƒã®é€æ˜åº¦ */
            transition: all 0.4s ease;
            z-index: -1; /* æ–‡å­—ã®è£ã«è¡¨ç¤º */
        }
        .horse-card:hover::before {
            opacity: 0.3;
            transform: scale(1.1); /* ãƒ›ãƒãƒ¼æ™‚ã«å°‘ã—æ‹¡å¤§ */
        }
        .horse-card > * {
            position: relative; /* æ–‡å­—ãŒèƒŒæ™¯ç”»åƒã®ä¸Šã«ãã‚‹ã‚ˆã†ã« */
        }
        /* â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜…â˜… */
        
        .horse-card:hover { border-color: #9c27b0; }
        .horse-card.selected { border-color: #6a1b9a; transform: scale(1.05); background: #f3e5f5; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .horse-emoji { font-size: 2rem; margin-bottom: 10px; }
        .horse-name { font-size: 1.2rem; font-weight: bold; color: #333; margin-bottom: 5px; text-shadow: 0 0 5px white; } /* æ–‡å­—ã‚’èª­ã¿ã‚„ã™ã */
        .horse-lane { font-size: 0.9rem; color: #666; text-shadow: 0 0 5px white; } /* æ–‡å­—ã‚’èª­ã¿ã‚„ã™ã */
        .player-count-selection { display: flex; justify-content: center; gap: 15px; margin-bottom: 30px; }
        .count-button { background: #f0f0f0; border: 2px solid #ccc; padding: 12px 25px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .count-button:hover { background: #e0e0e0; border-color: #aaa; }
        .start-button { display: block; margin: 0 auto; background: #6a1b9a; color: white; border: none; padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .start-button:hover { background: #4a148c; }
        .racing-phase, .result-phase { text-align: center; }
        .racing-phase h2 { font-size: 1.8rem; color: #333; margin-bottom: 15px; }
        .prediction { font-size: 1.1rem; color: #666; }
        .result-phase h2 { font-size: 2.2rem; color: #6a1b9a; margin-bottom: 20px; }
        .winner-announcement { font-size: 1.5rem; color: #6a1b9a; margin-bottom: 10px; }
        .celebration { font-size: 3rem; margin-bottom: 20px; }
        .result-message { padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .success { background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32; }
        .failure { background: #ffebee; border: 2px solid #f44336; color: #c62828; }
        .result-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 10px; }
        .points { font-size: 1.1rem; }
        .reset-button { background: #1565c0; color: white; border: none; padding: 12px 30px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(21, 101, 192, 0.3); }
        .reset-button:hover { background: #0d47a1; }
        #loadingOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; font-size: 2rem; color: #333; z-index: 100; }
        @media (max-width: 768px) {
            .title { font-size: 2rem; }
            .stats { flex-direction: column; gap: 15px; }
            .horse-selection { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">Now Loading...</div>
    
    <div class="container"></div>

    <audio id="raceBgm" src="race_bgm.mp3" loop></audio>

    <script>
        // å¤‰æ•°å®šç¾©
        let obstacles = [], obstacleMeshes = [], stumbleTimers = [];
        let gameState = 'setup', selectedHorse = null, winner = null, score = 0, raceCount = 0;
        let numHorses = 0, raceProgress = [], speeds = [];
        let scene, camera, renderer, characters = [], animationId;
        const allHorses = [
            { id: 0, name: 'ã‚·ãƒ£ã‚ªãƒ©ãƒ³' }, { id: 1, name: 'ã‚µã‚¯ãƒ¤' },
            { id: 2, name: 'ãƒãƒ ' }, { id: 3, name: 'ãƒ’ãƒŠãƒã‚¸ãƒ§ã‚¦' }
        ];
        let currentHorses = [];
        const TRACK_LENGTH = 20, FINISH_LINE = 18, MAX_HORSES = 4;
        const characterImageFiles = ['syaoran1.webp', 'sakuya1.webp', 'remu1.webp', 'hinanojyou1.webp']; // ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç§»å‹•

        // åˆæœŸåŒ–é–¢æ•°
        function init() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 12); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-5, 10, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const trackWidth = MAX_HORSES * 2;
            const trackGeometry = new THREE.PlaneGeometry(trackWidth, TRACK_LENGTH);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2; track.receiveShadow = true; scene.add(track);
            const startLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const startLineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const startLine = new THREE.Mesh(startLineGeometry, startLineMaterial);
            startLine.position.set(0, 0.01, -TRACK_LENGTH/2 + 1); scene.add(startLine);
            const finishLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const finishLineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const finishLine = new THREE.Mesh(finishLineGeometry, finishLineMaterial);
            finishLine.position.set(0, 0.01, TRACK_LENGTH/2 - 1); scene.add(finishLine);

            const loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => {
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('setupPhase').style.display = 'block';
            };
            const textureLoader = new THREE.TextureLoader(loadingManager);
            
            for (let i = 0; i < MAX_HORSES; i++) {
                const texture = textureLoader.load(characterImageFiles[i]);
                const planeGeometry = new THREE.PlaneGeometry(1.2, 1.8);
                const planeMaterial = new THREE.MeshLambertMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const characterPlane = new THREE.Mesh(planeGeometry, planeMaterial);
                characterPlane.castShadow = true; characterPlane.visible = false;
                // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šã‚¸ãƒ£ãƒ³ãƒ—ã®çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¿½åŠ  â˜…â˜…â˜…
                characterPlane.jumpState = { active: false, startTime: 0 };
                characters.push(characterPlane); scene.add(characterPlane);
            }
        }
        
        // éšœå®³ç‰©ç”Ÿæˆé–¢æ•°
        function createSingleObstacle(lane, positionZ) {
            const lanePositionX = (lane - (numHorses - 1) / 2) * 2;
            for(const obs of obstacles) {
                if (Math.abs(obs.z - positionZ) < 2.0) { return; }
            }
            const isRock = Math.random() > 0.5;
            const obstacleData = { lane, z: positionZ };
            obstacles.push(obstacleData);
            let obstacleMesh;
            if(isRock) {
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.25, positionZ);
            } else {
                const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const material = new THREE.MeshStandardMaterial({ color: 0x4e342e });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.05, positionZ);
            }
            obstacleMesh.castShadow = true;
            scene.add(obstacleMesh);
            obstacleMeshes.push(obstacleMesh);
        }
        
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šã‚¸ãƒ£ãƒ³ãƒ—é–¢æ•°ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã« â˜…â˜…â˜…
        // ã‚¸ãƒ£ãƒ³ãƒ—ã®é–‹å§‹ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã ã‘ã€‚å®Ÿéš›ã®å‹•ãã¯animateé–¢æ•°ã§å‡¦ç†
        function jumpCharacter(index) { 
            const character = characters[index];
            if (character.jumpState.active) return;
            character.jumpState = { active: true, startTime: Date.now() };
        }

        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šã‚«ãƒ¼ãƒ‰ç”Ÿæˆæ™‚ã«èƒŒæ™¯ç”»åƒã‚‚è¨­å®š â˜…â˜…â˜…
        function generateHorseSelection() {
            const selectionDiv = document.getElementById('horseSelection');
            selectionDiv.innerHTML = '';
            currentHorses.forEach((horse, index) => {
                const card = document.createElement('div');
                card.className = 'horse-card';
                card.dataset.horse = index;
                // CSSã®ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ä½¿ã£ã¦èƒŒæ™¯ç”»åƒã‚’æŒ‡å®š
                card.style.setProperty('--char-bg', `url('${characterImageFiles[index]}')`);
                
                card.innerHTML = ` <div class="horse-emoji">ğŸƒâ€â™€ï¸</div> <div class="horse-name">${horse.name}</div> <div class="horse-lane">ãƒ¬ãƒ¼ãƒ³ ${index + 1}</div> `; 
                card.addEventListener('click', () => { 
                    document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected')); 
                    card.classList.add('selected'); 
                    selectedHorse = index; 
                }); 
                selectionDiv.appendChild(card); 
            }); 
        }

        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å‡¦ç†ã‚’å¤§å¹…ã«æ”¹å–„ â˜…â˜…â˜…
        function animate() {
            animationId = requestAnimationFrame(animate);
            const now = Date.now();

            characters.forEach((character, index) => {
                // 1. ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
                if (character.jumpState.active) {
                    const JUMP_DURATION = 600; // ã‚¸ãƒ£ãƒ³ãƒ—ã®æ™‚é–“ (ãƒŸãƒªç§’)
                    const JUMP_HEIGHT = 1.0;
                    const elapsedTime = now - character.jumpState.startTime;

                    if (elapsedTime >= JUMP_DURATION) {
                        character.position.y = 0.9; // ã‚¸ãƒ£ãƒ³ãƒ—å®Œäº†
                        character.jumpState.active = false;
                    } else {
                        // sinã‚«ãƒ¼ãƒ–ã§æ»‘ã‚‰ã‹ãªã‚¸ãƒ£ãƒ³ãƒ—ã‚’è¡¨ç¾
                        const jumpProgress = elapsedTime / JUMP_DURATION;
                        character.position.y = 0.9 + Math.sin(jumpProgress * Math.PI) * JUMP_HEIGHT;
                    }
                }

                // 2. ãƒ¬ãƒ¼ã‚¹ä¸­ã®å·¦å³ã®æºã‚Œ
                if (gameState === 'racing' && !character.jumpState.active) {
                    const time = now * 0.01;
                    character.rotation.y = Math.sin(time + index * 2) * 0.1;
                }
                
                // 3. Zæ–¹å‘ï¼ˆå‰é€²ï¼‰ã®ã‚¹ãƒ ãƒ¼ã‚ºãªç§»å‹•
                if (index < numHorses) {
                    const startZ = -TRACK_LENGTH / 2 + 1;
                    const targetZ = startZ + raceProgress[index];
                    character.position.z = THREE.MathUtils.lerp(character.position.z, targetZ, 0.1);
                }
            });

            renderer.render(scene, camera);
        }

        // ãƒ¬ãƒ¼ã‚¹é–‹å§‹å‡¦ç†
        function startRace() {
            if (selectedHorse === null) { alert('äºˆæƒ³ã™ã‚‹å¿ã³ã‚’é¸ã‚“ã§ãã ã•ã„ï¼'); return; }

            stumbleTimers = new Array(numHorses).fill(0);
            let spawnedObstacleCount = 0;
            const MAX_OBSTACLES_PER_RACE = 2;

            const raceBgm = document.getElementById('raceBgm');
            raceBgm.play().catch(e => console.error("BGMã®å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸ:", e));

            gameState = 'racing';
            raceProgress = new Array(numHorses).fill(0);
            speeds = new Array(numHorses).fill(0);
            winner = null;

            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'block';
            document.getElementById('selectedHorseName').textContent = currentHorses[selectedHorse].name;

            const raceInterval = setInterval(() => {
                if (spawnedObstacleCount < MAX_OBSTACLES_PER_RACE && Math.random() < 0.015) {
                    let leaderIndex = 0, maxProgress = 0;
                    raceProgress.forEach((prog, index) => { if (prog > maxProgress) { maxProgress = prog; leaderIndex = index; } });
                    const spawnZ = -TRACK_LENGTH / 2 + 1 + maxProgress + 3.0;
                    if (spawnZ < FINISH_LINE - 2) { createSingleObstacle(leaderIndex, spawnZ); spawnedObstacleCount++; }
                }

                for (let i = 0; i < numHorses; i++) {
                    const character = characters[i];
                    if (stumbleTimers[i] > 0) {
                        stumbleTimers[i]--; speeds[i] = 0;
                        if (stumbleTimers[i] === 0) character.rotation.x = 0;
                        continue;
                    }
                    let obstacleAhead = false;
                    const characterZ = -TRACK_LENGTH / 2 + 1 + raceProgress[i];
                    for (const obs of obstacles) {
                        if (obs.lane === i && obs.z > characterZ && obs.z - characterZ < 1.5) {
                            obstacleAhead = true; break;
                        }
                    }
                    if (obstacleAhead && !character.jumpState.active) {
                        if (Math.random() < 0.7) { jumpCharacter(i); } 
                        else { stumbleTimers[i] = 20; character.rotation.x = 0.5; }
                    }
                    speeds[i] = Math.random() * 0.18 + 0.04;
                    raceProgress[i] = Math.min(FINISH_LINE, raceProgress[i] + speeds[i]);
                }

                const finished = raceProgress.findIndex(progress => progress >= FINISH_LINE);
                if (finished !== -1) {
                    clearInterval(raceInterval); winner = finished; gameState = 'finished';
                    if (finished === selectedHorse) score += 10;
                    raceCount++; updateUI(); showResult();
                }
            }, 100);
        }
        
        // â˜…â˜…â˜… å¤‰æ›´ç‚¹ï¼šãƒªã‚»ãƒƒãƒˆæ™‚ã«ã‚¸ãƒ£ãƒ³ãƒ—çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ â˜…â˜…â˜…
        function resetGame() {
            const raceBgm = document.getElementById('raceBgm');
            raceBgm.pause(); raceBgm.currentTime = 0;
            obstacleMeshes.forEach(mesh => scene.remove(mesh));
            obstacles = []; obstacleMeshes = [];
            gameState = 'setup'; selectedHorse = null; winner = null;
            numHorses = 0; currentHorses = [];
            characters.forEach(c => { 
                c.visible = false; 
                c.rotation.set(0,0,0); 
                c.jumpState.active = false; // ã‚¸ãƒ£ãƒ³ãƒ—çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            });
            document.getElementById('resultPhase').style.display = 'none';
            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'none';
            document.getElementById('setupPhase').style.display = 'block';
        }

        // ã“ã‚Œä»¥é™ã®é–¢æ•°ã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“
        function setupRace(count) { numHorses = count; currentHorses = allHorses.slice(0, numHorses); gameState = 'betting'; document.getElementById('setupPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'block'; generateHorseSelection(); resetCharacters(); }
        function resetCharacters() { characters.forEach((character, index) => { if (index < numHorses) { character.visible = true; const lanePositionX = (index - (numHorses - 1) / 2) * 2; character.position.set(lanePositionX, 0.9, -TRACK_LENGTH / 2 + 1); } else { character.visible = false; } }); }
        function showResult() { document.getElementById('racingPhase').style.display = 'none'; document.getElementById('resultPhase').style.display = 'block'; document.getElementById('winnerName').textContent = currentHorses[winner].name; const resultMessage = document.getElementById('resultMessage'); const resultTitle = resultMessage.querySelector('.result-title'); const points = resultMessage.querySelector('.points'); if (selectedHorse === winner) { resultMessage.className = 'result-message success'; resultTitle.textContent = 'ğŸ‰ äºˆæƒ³çš„ä¸­ï¼ ğŸ‰'; points.textContent = '+10ãƒã‚¤ãƒ³ãƒˆç²å¾—ï¼'; } else { resultMessage.className = 'result-message failure'; resultTitle.textContent = 'ğŸ˜… äºˆæƒ³å¤–ã‚Œ...'; points.textContent = `ã‚ãªãŸã®äºˆæƒ³: ${currentHorses[selectedHorse].name}`; } }
        function updateUI() { document.getElementById('score').textContent = score; document.getElementById('raceCount').textContent = raceCount; }
        window.addEventListener('load', () => { init(); animate(); window.addEventListener('resize', onWindowResize); });
    </script>
</body>
</html>
