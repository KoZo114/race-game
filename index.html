<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êé®Âøç„Å≥„ÉÄ„Éº„Éì„Éº</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #e3f2fd, #e8f5e8); min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .title { font-size: 2.5rem; font-weight: bold; color: #6a1b9a; margin-bottom: 10px; }
        .stats { display: flex; justify-content: center; gap: 30px; margin-bottom: 20px; }
        .stat-item { background: white; padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .score { color: #2e7d32; font-weight: bold; }
        .race-count { color: #1565c0; font-weight: bold; }
        .viewport { background: white; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; overflow: hidden; position: relative; }
        #gameCanvas { width: 100%; height: 400px; display: block; }
        .control-panel { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .phase-title { text-align: center; font-size: 1.8rem; color: #333; margin-bottom: 30px; }
        .horse-selection { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .horse-card { padding: 20px; border: 3px solid #e0e0e0; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-align: center; background: #f5f5f5; position: relative; overflow: hidden; z-index: 1; }
        .horse-card::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: var(--char-bg); background-size: cover; background-position: center; opacity: 0.15; transition: all 0.4s ease; z-index: -1; }
        .horse-card:hover::before { opacity: 0.3; transform: scale(1.1); }
        .horse-card > * { position: relative; }
        .horse-card:hover { border-color: #9c27b0; }
        .horse-card.selected { border-color: #6a1b9a; transform: scale(1.05); background: #f3e5f5; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .horse-emoji { font-size: 2rem; margin-bottom: 10px; }
        .horse-name { font-size: 1.2rem; font-weight: bold; color: #333; margin-bottom: 5px; text-shadow: 0 0 5px white; }
        .horse-lane { font-size: 0.9rem; color: #666; text-shadow: 0 0 5px white; }
        .player-count-selection { display: flex; justify-content: center; gap: 15px; margin-bottom: 30px; }
        .count-button { background: #f0f0f0; border: 2px solid #ccc; padding: 12px 25px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .count-button:hover { background: #e0e0e0; border-color: #aaa; }
        .start-button { display: block; margin: 0 auto; background: #6a1b9a; color: white; border: none; padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .start-button:hover { background: #4a148c; }
        .racing-phase, .result-phase { text-align: center; }
        .racing-phase h2 { font-size: 1.8rem; color: #333; margin-bottom: 15px; }
        .prediction { font-size: 1.1rem; color: #666; }
        .result-phase h2 { font-size: 2.2rem; color: #6a1b9a; margin-bottom: 20px; }
        .winner-announcement { font-size: 1.5rem; color: #6a1b9a; margin-bottom: 10px; }
        .celebration { font-size: 3rem; margin-bottom: 20px; }
        .result-message { padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .success { background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32; }
        .failure { background: #ffebee; border: 2px solid #f44336; color: #c62828; }
        .result-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 10px; }
        .points { font-size: 1.1rem; }
        .reset-button { background: #1565c0; color: white; border: none; padding: 12px 30px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(21, 101, 192, 0.3); }
        .reset-button:hover { background: #0d47a1; }
        #loadingOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; font-size: 2rem; color: #333; z-index: 100; }
        @media (max-width: 768px) { .title { font-size: 2rem; } .stats { flex-direction: column; gap: 15px; } .horse-selection { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="loadingOverlay">Now Loading...</div>
    
    <div class="container">
        <div class="header">
            <h1 class="title"> Êé®Âøç„Å≥„ÉÄ„Éº„Éì„Éº </h1>
            <div class="stats">
                <div class="stat-item">
                    <span class="score">„Çπ„Ç≥„Ç¢: <span id="score">0</span>ÁÇπ</span>
                </div>
                <div class="stat-item">
                    <span class="race-count">„É¨„Éº„ÇπÂõûÊï∞: <span id="raceCount">0</span></span>
                </div>
            </div>
        </div>
        <div class="viewport">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div class="control-panel">
            <div id="setupPhase" style="display: none;">
                <h2 class="phase-title">„É¨„Éº„Çπ„ÅÆ‰∫∫Êï∞„ÇíÈÅ∏„Çì„Åß„Å≠ÔºÅ</h2>
                <div class="player-count-selection">
                    <button class="count-button" onclick="setupRace(2)">2‰∫∫</button>
                    <button class="count-button" onclick="setupRace(3)">3‰∫∫</button>
                    <button class="count-button" onclick="setupRace(4)">4‰∫∫</button>
                </div>
            </div>
            <div id="bettingPhase" class="betting-phase" style="display: none;">
                <h2 class="phase-title">„Å©„ÅÆÂøç„Å≥„ÅåÂãù„Å§„Åã‰∫àÊÉ≥„Åó„Çà„ÅÜÔºÅ</h2>
                <div class="horse-selection" id="horseSelection"></div>
                <button class="start-button" onclick="startRace()">üöÄ „É¨„Éº„ÇπÈñãÂßãÔºÅ</button>
            </div>
            <div id="racingPhase" class="racing-phase" style="display: none;">
                <h2>üèÅ „É¨„Éº„Çπ‰∏≠... üèÅ</h2>
                <div class="prediction">„ÅÇ„Å™„Åü„ÅÆ‰∫àÊÉ≥: <span id="selectedHorseName"></span></div>
            </div>
            <div id="resultPhase" class="result-phase" style="display: none;">
                <h2>üèÜ „É¨„Éº„ÇπÁµêÊûú üèÜ</h2>
                <div class="winner-announcement">ÂÑ™Âãù: <span id="winnerName"></span>ÔºÅ</div>
                <div class="celebration">üéâ</div>
                <div id="resultMessage" class="result-message">
                    <div class="result-title"></div>
                    <div class="points"></div>
                </div>
                <button class="reset-button" onclick="resetGame()">üîÑ „ÇÇ„ÅÜ‰∏ÄÂ∫¶„É¨„Éº„Çπ</button>
            </div>
        </div>
    </div>

    <audio id="raceBgm" src="race_bgm.mp3" loop></audio>

    <script>
        let obstacles = [], obstacleMeshes = [], stumbleTimers = [];
        let gameState = 'setup', selectedHorse = null, winner = null, score = 0, raceCount = 0;
        let numHorses = 0, raceProgress = [], speeds = [];
        let scene, camera, renderer, characters = [], animationId;
        const allHorses = [
            { id: 0, name: '„Ç∑„É£„Ç™„É©„É≥' }, { id: 1, name: '„Çµ„ÇØ„É§' },
            { id: 2, name: '„Éç„É†' }, { id: 3, name: '„Éí„Éä„Éé„Ç∏„Éß„Ç¶' }
        ];
        let currentHorses = [];
        const TRACK_LENGTH = 20, FINISH_LINE = 18, MAX_HORSES = 4;
        const characterImageFiles = ['syaoran1.webp', 'sakuya1.webp', 'remu1.webp', 'hinanojyou1.webp'];

        function init() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 12); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-5, 10, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const trackWidth = MAX_HORSES * 2;
            const trackGeometry = new THREE.PlaneGeometry(trackWidth, TRACK_LENGTH);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2; track.receiveShadow = true; scene.add(track);
            const startLine = new THREE.Mesh(new THREE.BoxGeometry(trackWidth, 0.02, 0.1), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            startLine.position.set(0, 0.01, -TRACK_LENGTH/2 + 1); scene.add(startLine);
            const finishLine = new THREE.Mesh(new THREE.BoxGeometry(trackWidth, 0.02, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            finishLine.position.set(0, 0.01, TRACK_LENGTH/2 - 1); scene.add(finishLine);

            const loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => {
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('setupPhase').style.display = 'block';
            };
            const textureLoader = new THREE.TextureLoader(loadingManager);
            for (let i = 0; i < MAX_HORSES; i++) {
                const texture = textureLoader.load(characterImageFiles[i]);
                const planeMaterial = new THREE.MeshLambertMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const characterPlane = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.8), planeMaterial);
                characterPlane.castShadow = true; characterPlane.visible = false;
                characterPlane.jumpState = { active: false, startTime: 0 };
                characters.push(characterPlane); scene.add(characterPlane);
            }
        }
        
        function createSingleObstacle(lane, positionZ) {
            const lanePositionX = (lane - (numHorses - 1) / 2) * 2;
            for(const obs of obstacles) { if (Math.abs(obs.z - positionZ) < 2.0) return; }
            const isRock = Math.random() > 0.5;
            const obstacleData = { lane, z: positionZ };
            obstacles.push(obstacleData);
            let obstacleMesh;
            if(isRock) {
                obstacleMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x8d6e63 }));
                obstacleMesh.position.set(lanePositionX, 0.25, positionZ);
            } else {
                obstacleMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x4e342e }));
                obstacleMesh.position.set(lanePositionX, 0.05, positionZ);
            }
            obstacleMesh.castShadow = true; scene.add(obstacleMesh); obstacleMeshes.push(obstacleMesh);
        }
        
        function jumpCharacter(index) { 
            const character = characters[index];
            if (character.jumpState.active) return;
            character.jumpState = { active: true, startTime: Date.now() };
        }

        function generateHorseSelection() {
            const selectionDiv = document.getElementById('horseSelection');
            selectionDiv.innerHTML = '';
            currentHorses.forEach((horse, index) => {
                const card = document.createElement('div');
                card.className = 'horse-card';
                card.dataset.horse = index;
                card.style.setProperty('--char-bg', `url('${characterImageFiles[index]}')`);
                card.innerHTML = ` <div class="horse-emoji">üèÉ‚Äç‚ôÄÔ∏è</div> <div class="horse-name">${horse.name}</div> <div class="horse-lane">„É¨„Éº„É≥ ${index + 1}</div> `; 
                card.addEventListener('click', () => { 
                    document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected')); 
                    card.classList.add('selected'); 
                    selectedHorse = index; 
                }); 
                selectionDiv.appendChild(card); 
            }); 
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            const now = Date.now();
            characters.forEach((character, index) => {
                if (character.jumpState.active) {
                    const JUMP_DURATION = 600, JUMP_HEIGHT = 1.0, elapsedTime = now - character.jumpState.startTime;
                    if (elapsedTime >= JUMP_DURATION) {
                        character.position.y = 0.9; character.jumpState.active = false;
                    } else {
                        const jumpProgress = elapsedTime / JUMP_DURATION;
                        character.position.y = 0.9 + Math.sin(jumpProgress * Math.PI) * JUMP_HEIGHT;
                    }
                }
                if (gameState === 'racing' && !character.jumpState.active) {
                    character.rotation.y = Math.sin(now * 0.01 + index * 2) * 0.1;
                }
                if (index < numHorses) {
                    const targetZ = -TRACK_LENGTH / 2 + 1 + raceProgress[index];
                    character.position.z = THREE.MathUtils.lerp(character.position.z, targetZ, 0.1);
                }
            });
            renderer.render(scene, camera);
        }

        function startRace() {
            if (selectedHorse === null) { alert('‰∫àÊÉ≥„Åô„ÇãÂøç„Å≥„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑÔºÅ'); return; }
            stumbleTimers = new Array(numHorses).fill(0);
            let spawnedObstacleCount = 0;
            const MAX_OBSTACLES_PER_RACE = 2;
            const raceBgm = document.getElementById('raceBgm');
            raceBgm.play().catch(e => console.error("BGM„ÅÆÂÜçÁîü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", e));
            gameState = 'racing';
            raceProgress = new Array(numHorses).fill(0);
            speeds = new Array(numHorses).fill(0);
            winner = null;
            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'block';
            document.getElementById('selectedHorseName').textContent = currentHorses[selectedHorse].name;

            const raceInterval = setInterval(() => {
                if (spawnedObstacleCount < MAX_OBSTACLES_PER_RACE && Math.random() < 0.015) {
                    let leaderIndex = 0, maxProgress = 0;
                    raceProgress.forEach((prog, index) => { if (prog > maxProgress) { maxProgress = prog; leaderIndex = index; } });
                    const spawnZ = -TRACK_LENGTH / 2 + 1 + maxProgress + 3.0;
                    if (spawnZ < FINISH_LINE - 2) { createSingleObstacle(leaderIndex, spawnZ); spawnedObstacleCount++; }
                }
                for (let i = 0; i < numHorses; i++) {
                    const character = characters[i];
                    if (stumbleTimers[i] > 0) {
                        stumbleTimers[i]--; speeds[i] = 0;
                        if (stumbleTimers[i] === 0) character.rotation.x = 0;
                        continue;
                    }
                    let obstacleAhead = false;
                    const characterZ = -TRACK_LENGTH / 2 + 1 + raceProgress[i];
                    for (const obs of obstacles) {
                        if (obs.lane === i && obs.z > characterZ && obs.z - characterZ < 1.5) {
                            obstacleAhead = true; break;
                        }
                    }
                    if (obstacleAhead && !character.jumpState.active) {
                        if (Math.random() < 0.7) { jumpCharacter(i); } 
                        else { stumbleTimers[i] = 20; character.rotation.x = 0.5; }
                    }
                    speeds[i] = Math.random() * 0.18 + 0.04;
                    raceProgress[i] = Math.min(FINISH_LINE, raceProgress[i] + speeds[i]);
                }
                const finished = raceProgress.findIndex(progress => progress >= FINISH_LINE);
                if (finished !== -1) {
                    clearInterval(raceInterval); winner = finished; gameState = 'finished';
                    if (finished === selectedHorse) score += 10;
                    raceCount++; updateUI(); showResult();
                }
            }, 100);
        }
        
        function resetGame() {
            const raceBgm = document.getElementById('raceBgm');
            raceBgm.pause(); raceBgm.currentTime = 0;
            obstacleMeshes.forEach(mesh => scene.remove(mesh));
            obstacles = []; obstacleMeshes = [];
            gameState = 'setup'; selectedHorse = null; winner = null;
            numHorses = 0; currentHorses = [];
            characters.forEach(c => { 
                c.visible = false; c.rotation.set(0,0,0); c.jumpState.active = false;
            });
            document.getElementById('resultPhase').style.display = 'none';
            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'none';
            document.getElementById('setupPhase').style.display = 'block';
        }

        function setupRace(count) { numHorses = count; currentHorses = allHorses.slice(0, numHorses); gameState = 'betting'; document.getElementById('setupPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'block'; generateHorseSelection(); resetCharacters(); }
        function resetCharacters() { characters.forEach((character, index) => { if (index < numHorses) { character.visible = true; const lanePositionX = (index - (numHorses - 1) / 2) * 2; character.position.set(lanePositionX, 0.9, -TRACK_LENGTH / 2 + 1); } else { character.visible = false; } }); }
        function showResult() { document.getElementById('racingPhase').style.display = 'none'; document.getElementById('resultPhase').style.display = 'block'; document.getElementById('winnerName').textContent = currentHorses[winner].name; const resultMessage = document.getElementById('resultMessage'); const resultTitle = resultMessage.querySelector('.result-title'); const points = resultMessage.querySelector('.points'); if (selectedHorse === winner) { resultMessage.className = 'result-message success'; resultTitle.textContent = 'üéâ ‰∫àÊÉ≥ÁöÑ‰∏≠ÔºÅ üéâ'; points.textContent = '+10„Éù„Ç§„É≥„ÉàÁç≤ÂæóÔºÅ'; } else { resultMessage.className = 'result-message failure'; resultTitle.textContent = 'üòÖ ‰∫àÊÉ≥Â§ñ„Çå...'; points.textContent = `„ÅÇ„Å™„Åü„ÅÆ‰∫àÊÉ≥: ${currentHorses[selectedHorse].name}`; } }
        function updateUI() { document.getElementById('score').textContent = score; document.getElementById('raceCount').textContent = raceCount; }
        window.addEventListener('load', () => { init(); animate(); window.addEventListener('resize', onWindowResize); });
    </script>
</body>
</html>
