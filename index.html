<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>推忍びダービー</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* CSSは変更ありません */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(to bottom, #e3f2fd, #e8f5e8); min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .title { font-size: 2.5rem; font-weight: bold; color: #6a1b9a; margin-bottom: 10px; }
        .stats { display: flex; justify-content: center; gap: 30px; margin-bottom: 20px; }
        .stat-item { background: white; padding: 10px 20px; border-radius: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .score { color: #2e7d32; font-weight: bold; }
        .race-count { color: #1565c0; font-weight: bold; }
        .viewport { background: white; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; overflow: hidden; position: relative; }
        #gameCanvas { width: 100%; height: 400px; display: block; }
        .control-panel { background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .phase-title { text-align: center; font-size: 1.8rem; color: #333; margin-bottom: 30px; }
        .horse-selection { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .horse-card { padding: 20px; border: 3px solid #e0e0e0; border-radius: 10px; cursor: pointer; transition: all 0.3s ease; text-align: center; background: #f5f5f5; }
        .horse-card:hover { border-color: #9c27b0; }
        .horse-card.selected { border-color: #6a1b9a; transform: scale(1.05); background: #f3e5f5; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .horse-emoji { font-size: 2rem; margin-bottom: 10px; }
        .horse-name { font-size: 1.2rem; font-weight: bold; color: #333; margin-bottom: 5px; }
        .horse-lane { font-size: 0.9rem; color: #666; }
        .player-count-selection { display: flex; justify-content: center; gap: 15px; margin-bottom: 30px; }
        .count-button { background: #f0f0f0; border: 2px solid #ccc; padding: 12px 25px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; }
        .count-button:hover { background: #e0e0e0; border-color: #aaa; }
        .start-button { display: block; margin: 0 auto; background: #6a1b9a; color: white; border: none; padding: 15px 40px; font-size: 1.2rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3); }
        .start-button:hover { background: #4a148c; }
        .racing-phase, .result-phase { text-align: center; }
        .racing-phase h2 { font-size: 1.8rem; color: #333; margin-bottom: 15px; }
        .prediction { font-size: 1.1rem; color: #666; }
        .result-phase h2 { font-size: 2.2rem; color: #6a1b9a; margin-bottom: 20px; }
        .winner-announcement { font-size: 1.5rem; color: #6a1b9a; margin-bottom: 10px; }
        .celebration { font-size: 3rem; margin-bottom: 20px; }
        .result-message { padding: 20px; border-radius: 10px; margin-bottom: 20px; }
        .success { background: #e8f5e9; border: 2px solid #4caf50; color: #2e7d32; }
        .failure { background: #ffebee; border: 2px solid #f44336; color: #c62828; }
        .result-title { font-size: 1.3rem; font-weight: bold; margin-bottom: 10px; }
        .points { font-size: 1.1rem; }
        .reset-button { background: #1565c0; color: white; border: none; padding: 12px 30px; font-size: 1.1rem; border-radius: 50px; cursor: pointer; transition: background 0.3s ease; box-shadow: 0 4px 15px rgba(21, 101, 192, 0.3); }
        .reset-button:hover { background: #0d47a1; }
        #loadingOverlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); display: flex; justify-content: center; align-items: center; font-size: 2rem; color: #333; z-index: 100; }
        @media (max-width: 768px) {
            .title { font-size: 2rem; }
            .stats { flex-direction: column; gap: 15px; }
            .horse-selection { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div id="loadingOverlay">Now Loading...</div>
    
    <div class="container"></div>

    <audio id="raceBgm" src="race_bgm.mp3" loop></audio>

    <script>
        // 変数・定数は変更なし
        let obstacles = [], obstacleMeshes = [], stumbleTimers = [];
        let gameState = 'setup', selectedHorse = null, winner = null, score = 0, raceCount = 0;
        let numHorses = 0, raceProgress = [], speeds = [];
        let scene, camera, renderer, characters = [], animationId;
        const allHorses = [
            { id: 0, name: 'シャオラン' }, { id: 1, name: 'サクヤ' },
            { id: 2, name: 'ネム' }, { id: 3, name: 'ヒナノジョウ' }
        ];
        let currentHorses = [];
        const TRACK_LENGTH = 20, FINISH_LINE = 18, MAX_HORSES = 4;

        // init関数は変更なし
        function init() {
            const canvas = document.getElementById('gameCanvas');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 12); camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-5, 10, 5); directionalLight.castShadow = true; scene.add(directionalLight);
            const trackWidth = MAX_HORSES * 2;
            const trackGeometry = new THREE.PlaneGeometry(trackWidth, TRACK_LENGTH);
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x6B8E23 });
            const track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2; track.receiveShadow = true; scene.add(track);
            const startLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const startLineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const startLine = new THREE.Mesh(startLineGeometry, startLineMaterial);
            startLine.position.set(0, 0.01, -TRACK_LENGTH/2 + 1); scene.add(startLine);
            const finishLineGeometry = new THREE.BoxGeometry(trackWidth, 0.02, 0.1);
            const finishLineMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const finishLine = new THREE.Mesh(finishLineGeometry, finishLineMaterial);
            finishLine.position.set(0, 0.01, TRACK_LENGTH/2 - 1); scene.add(finishLine);

            const loadingManager = new THREE.LoadingManager();
            loadingManager.onLoad = () => {
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('setupPhase').style.display = 'block';
            };
            const textureLoader = new THREE.TextureLoader(loadingManager);
            const characterImageFiles = ['syaoran1.webp', 'sakuya1.webp', 'remu1.webp', 'hinanojyou1.webp'];
            for (let i = 0; i < MAX_HORSES; i++) {
                const texture = textureLoader.load(characterImageFiles[i]);
                const planeGeometry = new THREE.PlaneGeometry(1.2, 1.8);
                const planeMaterial = new THREE.MeshLambertMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
                const characterPlane = new THREE.Mesh(planeGeometry, planeMaterial);
                characterPlane.castShadow = true; characterPlane.visible = false;
                characters.push(characterPlane); scene.add(characterPlane);
            }
        }
        
        // ★★★ 変更点：障害物を「１つだけ」生成する関数に変更 ★★★
        function createSingleObstacle(lane, positionZ) {
            const lanePositionX = (lane - (numHorses - 1) / 2) * 2;
            
            // 他の障害物と位置が近すぎる場合は生成しない
            for(const obs of obstacles) {
                if (Math.abs(obs.z - positionZ) < 2.0) {
                    return; // 位置が近すぎるので中止
                }
            }

            const isRock = Math.random() > 0.5;
            const obstacleData = { lane, z: positionZ };
            obstacles.push(obstacleData);

            let obstacleMesh;
            if(isRock) { // 岩
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.25, positionZ);
            } else { // もぐらの穴
                const geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.1, 16);
                const material = new THREE.MeshStandardMaterial({ color: 0x4e342e });
                obstacleMesh = new THREE.Mesh(geometry, material);
                obstacleMesh.position.set(lanePositionX, 0.05, positionZ);
            }
            obstacleMesh.castShadow = true;
            scene.add(obstacleMesh);
            obstacleMeshes.push(obstacleMesh);
        }
        
        // jumpCharacter関数は変更なし
        function jumpCharacter(index) { const character = characters[index]; if (character.isJumping) return; character.isJumping = true; const originalY = character.position.y; const jumpHeight = 1.0; let jumpProgress = 0; const jumpInterval = setInterval(() => { jumpProgress += 0.1; character.position.y = originalY + Math.sin(jumpProgress * Math.PI) * jumpHeight; if (jumpProgress >= 1) { character.position.y = originalY; character.isJumping = false; clearInterval(jumpInterval); } }, 30); }

        // ★★★ レース開始処理を大幅に変更 ★★★
        function startRace() {
            if (selectedHorse === null) { alert('予想する忍びを選んでください！'); return; }

            // ★★★ 変更点：レース開始時の障害物生成を削除 ★★★
            // generateObstacles(); // この行を削除

            stumbleTimers = new Array(numHorses).fill(0);
            let spawnedObstacleCount = 0; // このレースで生成した障害物の数をカウント
            const MAX_OBSTACLES_PER_RACE = 2; // レース中に生成する障害物の最大数

            const raceBgm = document.getElementById('raceBgm');
            raceBgm.play().catch(e => console.error("BGMの再生に失敗しました:", e));

            gameState = 'racing';
            raceProgress = new Array(numHorses).fill(0);
            speeds = new Array(numHorses).fill(0);
            winner = null;

            document.getElementById('bettingPhase').style.display = 'none';
            document.getElementById('racingPhase').style.display = 'block';
            document.getElementById('selectedHorseName').textContent = currentHorses[selectedHorse].name;

            const raceInterval = setInterval(() => {
                
                // ★★★ 追加点：レース中に障害物を動的に生成する処理 ★★★
                if (spawnedObstacleCount < MAX_OBSTACLES_PER_RACE && Math.random() < 0.015) {
                    // 1.5%の確率で障害物を生成
                    let leaderIndex = 0;
                    let maxProgress = 0;
                    // 現在のトップ走者を調べる
                    raceProgress.forEach((prog, index) => {
                        if (prog > maxProgress) {
                            maxProgress = prog;
                            leaderIndex = index;
                        }
                    });

                    // トップ走者の少し前に障害物を置く
                    const spawnZ = -TRACK_LENGTH / 2 + 1 + maxProgress + 3.0; // 3ユニット前
                    if (spawnZ < FINISH_LINE - 2) { // ゴール直前には置かない
                        createSingleObstacle(leaderIndex, spawnZ);
                        spawnedObstacleCount++;
                    }
                }

                // 各キャラクターの処理（ここは変更なし）
                for (let i = 0; i < numHorses; i++) {
                    const character = characters[i];
                    if (stumbleTimers[i] > 0) {
                        stumbleTimers[i]--;
                        speeds[i] = 0;
                        if (stumbleTimers[i] === 0) character.rotation.x = 0;
                        continue;
                    }

                    let obstacleAhead = false;
                    const characterZ = -TRACK_LENGTH / 2 + 1 + raceProgress[i];
                    for (const obs of obstacles) {
                        if (obs.lane === i && obs.z > characterZ && obs.z - characterZ < 1.5) {
                            obstacleAhead = true;
                            break;
                        }
                    }

                    if (obstacleAhead && !character.isJumping) {
// ジャンプを試みる確率 (調整可能)
if (Math.random() < 0.6) {
jumpCharacter(i);
} else {
// ジャンプに失敗した場合（またはジャンプを試みなかった場合）、つまずく確率
if (Math.random() < 0.7) {
stumbleTimers[i] = 20;
character.rotation.x = 0.5;
}
// つまずきも回避する可能性 (低確率)
}
}

                    speeds[i] = Math.random() * 0.18 + 0.04;
                    raceProgress[i] = Math.min(FINISH_LINE, raceProgress[i] + speeds[i]);
                }

                // ゴール判定（ここは変更なし）
                const finished = raceProgress.findIndex(progress => progress >= FINISH_LINE);
                if (finished !== -1) {
                    clearInterval(raceInterval);
                    winner = finished;
                    gameState = 'finished';
                    if (finished === selectedHorse) score += 10;
                    raceCount++;
                    updateUI();
                    showResult();
                }
            }, 100);
        }
        
        // これ以降の関数は変更ありません
        function resetGame() { const raceBgm = document.getElementById('raceBgm'); raceBgm.pause(); raceBgm.currentTime = 0; obstacleMeshes.forEach(mesh => scene.remove(mesh)); obstacles = []; obstacleMeshes = []; gameState = 'setup'; selectedHorse = null; winner = null; numHorses = 0; currentHorses = []; characters.forEach(c => { c.visible = false; c.rotation.set(0,0,0); c.isJumping = false; }); document.getElementById('resultPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'none'; document.getElementById('racingPhase').style.display = 'none'; document.getElementById('setupPhase').style.display = 'block'; }
        function setupRace(count) { numHorses = count; currentHorses = allHorses.slice(0, numHorses); gameState = 'betting'; document.getElementById('setupPhase').style.display = 'none'; document.getElementById('bettingPhase').style.display = 'block'; generateHorseSelection(); resetCharacters(); }
        function generateHorseSelection() { const selectionDiv = document.getElementById('horseSelection'); selectionDiv.innerHTML = ''; currentHorses.forEach((horse, index) => { const card = document.createElement('div'); card.className = 'horse-card'; card.dataset.horse = index; card.innerHTML = ` <div class="horse-emoji">🏃‍♀️</div> <div class="horse-name">${horse.name}</div> <div class="horse-lane">レーン ${index + 1}</div> `; card.addEventListener('click', () => { document.querySelectorAll('.horse-card').forEach(c => c.classList.remove('selected')); card.classList.add('selected'); selectedHorse = index; }); selectionDiv.appendChild(card); }); }
        function resetCharacters() { characters.forEach((character, index) => { if (index < numHorses) { character.visible = true; const lanePositionX = (index - (numHorses - 1) / 2) * 2; character.position.set(lanePositionX, 0.9, -TRACK_LENGTH / 2 + 1); } else { character.visible = false; } }); }
        function animate() { animationId = requestAnimationFrame(animate); if (gameState === 'racing') { characters.forEach((character, index) => { if (index < numHorses && !character.isJumping) { const time = Date.now() * 0.01; character.rotation.y = Math.sin(time + index * 2) * 0.1; } }); } characters.forEach((character, index) => { if (index < numHorses) { const startZ = -TRACK_LENGTH/2 + 1; const targetZ = startZ + raceProgress[index]; character.position.z = THREE.MathUtils.lerp(character.position.z, targetZ, 0.1); } }); renderer.render(scene, camera); }
        function onWindowResize() { const canvas = document.getElementById('gameCanvas'); if (canvas) { camera.aspect = canvas.clientWidth / canvas.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvas.clientWidth, canvas.clientHeight); } }
        function showResult() { document.getElementById('racingPhase').style.display = 'none'; document.getElementById('resultPhase').style.display = 'block'; document.getElementById('winnerName').textContent = currentHorses[winner].name; const resultMessage = document.getElementById('resultMessage'); const resultTitle = resultMessage.querySelector('.result-title'); const points = resultMessage.querySelector('.points'); if (selectedHorse === winner) { resultMessage.className = 'result-message success'; resultTitle.textContent = '🎉 予想的中！ 🎉'; points.textContent = '+10ポイント獲得！'; } else { resultMessage.className = 'result-message failure'; resultTitle.textContent = '😅 予想外れ...'; points.textContent = `あなたの予想: ${currentHorses[selectedHorse].name}`; } }
        function updateUI() { document.getElementById('score').textContent = score; document.getElementById('raceCount').textContent = raceCount; }
        window.addEventListener('load', () => { init(); animate(); window.addEventListener('resize', onWindowResize); });
    </script>
</body>
</html>
